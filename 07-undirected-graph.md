### 讨论关于无向图（undirected graph）遍历的问题
1. 首先是如何将无向图的遍历问题的引入？
  * a. 如何对一幅图（连通的图/非连通的图<存在极大连通子图>）中的所有节点进行遍历？使用最普通的方法？使用普通的方式进行遍历存在的问题是什么？
  首先，可以对问题进行转换。对于一幅图的遍历问题可以将其转换成为“访问一幅图中的所有顶点”。若访问的图是非连通的图，则需要依次访问完其所有的极大连通子图，<br>整幅图也会被访问完成。使用最简单的方式也可以访问完成一幅图中的所有节点，会存在这样的问题：<br>在遍历图中的所有顶点时，可能存在**重复访问某个顶点**的问题。其会导致遍历整个图的效率降低。
  
  * b.由最简单的方式引入到深度优先算法进行图的遍历？（先对深度优先dfs进行解释/一个人走胡同）。
   解释深度优先：当搜索一幅图时，只需用一个递归的方法来遍历所有的顶点。<br>
   1. 在访问一个顶点的时,首先将其标注为已经访问的状态。<br>
   2. 然后递归的访问与其相邻的其它顶点。<br>
   首先与普通访问一幅图的方法相比，它只会访问连通图中的所有顶点一次。其次，在访问完一个顶点之后，深度优先会递归的访问与其相邻接的其它顶点，<br>然后依次递归的访问与当前顶点的相邻顶点。递归就好像一个人在胡同里走，如果在岔路口一直有可以走下去的路，则其会一直沿着路口往深走。<br>
   3. 深度优先算法是如何实现的？<br>
   其在最开始构造图的时候使用一个`marked[]`数组来保存图中所有顶点是否被访问过，如果`marked[i]`的值为`true`则表示该顶点已经被访问过。<br>在进行遍历的时，首先将当前结点标记为已经访问过的状态，然后递归访问与当前顶点相邻的其它顶点。<br>注:需结合ppt上深度优先遍历图的路径。

  * c.如何使用广度优先对一幅图进行遍历(bfs)，首先什么是广度优先遍历？其与深度优先遍历相比有什么不同？（对广度优先进行描述/一群人走迷宫的问题）<br>
  问题的引入，广度优先的产生是为了解决单点最短路径的问题。给定一幅图和一个顶点s,回答"从s到给定目的顶点v是否存在一条路径?,<br>如果有找出其中最短的那条路径?",对于深度优先来说,它在此问题上没有什么见解.因为它遍历整个图的顺序和找出最短路径的目标没有什么关系。<br>
  相比之下使用广度优先处理s->v,描述:从s开始在所有由一条边就可以遍历到达的地方寻找v,如果找到了就进行返回。<br>否则,从与s距离两条边的地方进行查找,如果找到就直接进行返回。

  * d.广度优先搜索与深度优先搜索的区别是什么?(从描述上/实现上进行表述{栈和队列的存储方式}).<br>
  深度优先使用了一个下压堆栈Heap(FILO).由系统的递归进行栈的模拟。<br>
  广度优先是希望按照距离进行结点的查找，它对于相邻节点的查找是使用了FIFO的队列来进行表示的。<br>
  
  * e.从整个图的遍历延伸的问题，判断一幅图是否是连通图?(深度优先与广度优先的路径比较?)
  对图的遍历可以延伸到使用图遍历算法判断一幅图是否连通？如果在开始构造一幅图的时已知顶点的数量V-nums,以及边的数量edge-nums。<br>在使用深度优先或者广度优先对图记性遍历时，使用变量`count`进行引用计数，每访问一个之前没有访问过的节点，`count`的数量进行递增。<br>在遍历完成之后如果count的数量小于图中所有顶点的数量，则整幅图是不连通的。当`count==V-nums`的时候，则遍历的这幅图是连通的。<br>
  对于深度优先与广度优先的路径比较需要结合ppt进行展示。
  
2. 一幅图中单点路径问题的引入?(表明是在连通图的情况下).
  * a.什么是单点路径问题？(在一幅图中给定一个起点start,在图中是否存在到给定一个顶点的路径).
   对于一幅图和一个起点s，回答"从s到给定的目的顶点v是否存在一条路径?如果有,找出这条路径"。既然要找到路径就需要在遍历图的时候将路径保存下来。<br>在单点路径问题中使用了一个`edgeTo[]`的数组进行访问路径的保存工作，`edgeTo[3]=2`表示的是从s起点开始，通过节点2就可以直接访问到节点3.<br>
  
  * b.SearchAPI的定义。
  使用一幅图Graph和一个start顶点作为其构造函数，在进行图构造时使用`edgeTo[]`保存其遍历路径。
  
  * c.使用深度优先和广度优先解决单点路径问题？
  在使用深度优先遍历时需要在递归调用相邻顶点的dfs()方法之前需要通过edgeTo[]保存当前节点的访问关系。<br>
   使用广度优先遍历时需要注意在将相邻顶点加入到queue之前保存边的访问关系。<br>
  
  3.图的连通分量问题？(此问题是针对一幅图中存在极大连通子图的情况).
 
  * a.问题引入,对于一幅不连通的图(如何判断两个顶点之间是否存在路径).
  图的连通性,给定一幅图回答"两个顶点是否连通?"或者"图中有多少个连通子图"等类似的问题?<br>
  等价问题: 两个顶点之间是否连通<->两个给定的顶点之间是否存在一条路径?"也可以叫做路径检测问题?"
  
  * b.思路引入：连通的结点如何进行表示？如何用于区分不同的极大连通子图？
  在进行图构造的时候，将每一个极大连通子图中的结点分别使用一个连通分量进行表示。判断一幅图中的任意两个顶点是都存在路径，<br>就可以转换成为这两个顶点是否存在于同一个连通分量中。在图构造完成之后也可以得到整个图中所有的连通分量数。
  
  * c.图的连通分量的实现，如何找到一幅图中所有的连通分量？
  在图构造的时候，使用`id[]`数组记录图中所有节点的连通分量，使用count进行记录每个极大连通子图中的连通分量，每遍历完成一个极大连通子图后，<br>连通分量count数量会进行递增。最后转换的结果为判断节点的id[index]是否相同，如果相同则表明这两个顶点存在于同一个极大连通子图中。

4.如何检测一幅图中是否存在环或者平行边?
  
  * a.问题的引入：什么是环？以及什么是平行边？
  :环的定义: 环是一条至少包含一条边且起点和终点相同的路径。通俗来说就像地球一样，你从一个地方出发一直往前出发，最终你会回到你的出发点。<br>
  :平行边的定义: 连接同一对顶点的两条边称为平行边。
  b.你的思路是什么？如何对进行环和平行边的检测？(使用深度优先进行实现).
  使用深度优先算法实现图的遍历比较合适，对于环的检测依据：使用深度优先递归访问，如果递归访问的下一个节点是之前已经访问过的结点，<br>则这幅图中存在环(graph)路径<需要排除递归路径上当前节点的上一个访问节点>。
  
#### 使用深度优先遍历图的实现:
```java
public class DepthFirthSearch {
    /**
     * 是否已经访问过该节点.
     * */
    private boolean[] marked;

    /**
     * 表示与start连通的顶点的总数.
     * */
    private int count;

    public DepthFirthSearch(Graph graph, int start) {
        this.marked = new boolean[graph.V()];
        dfs(graph, start);
    }

    private void dfs(Graph graph, int vertex) {
        marked[vertex] = true;
        count++;
        for(int neighVertex : graph.adj(vertex)) {
            if(!marked[neighVertex]) {
                dfs(graph, neighVertex);
            }
        }
    }

    public boolean marked(int vertex) { return marked[vertex]; }
    public int count() { return count; }
}
```
#### 使用广度优先遍历一幅图的实现：
```java
public class BreadthFirstSearch {
    /**
     * 是否已经访问过该节点.
     * */
    private boolean[] marked;

    /**
     * 表示与start连通的顶点的总数.
     * */
    private int count;

    BreadthFirstSearch(Graph graph, int start) {
        this.marked = new boolean[graph.V()];
        bfs(graph, start);
    }

    private void bfs(Graph graph, int vertex) {
        Queue<Integer> queue = new LinkedBlockingQueue<Integer>();
        marked[vertex] = true;
        queue.add(vertex);
        while(!queue.isEmpty()) {
            int oldVertex = queue.poll();
            for(int w : graph.adj(oldVertex)) {
                if(!marked[w]) {
                    marked[w] = true;
                    count++;
                    queue.add(w);
                }
            }
        }
    }
}
```


